<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>LLVM Source-Based Code Coverage - Rust Compiler Development Guide</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A guide to developing the Rust compiler (rustc)">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="getting-started.html">Getting Started</a></li><li class="chapter-item affix "><a href="about-this-guide.html">About this guide</a></li><li class="spacer"></li><li class="chapter-item affix "><li class="part-title">Building and debugging rustc</li><li class="chapter-item "><a href="building/how-to-build-and-run.html"><strong aria-hidden="true">1.</strong> How to build and run the compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="building/quickstart.html"><strong aria-hidden="true">1.1.</strong> Quickstart</a></li><li class="chapter-item "><a href="building/prerequisites.html"><strong aria-hidden="true">1.2.</strong> Prerequisites</a></li><li class="chapter-item "><a href="building/suggested.html"><strong aria-hidden="true">1.3.</strong> Suggested Workflows</a></li><li class="chapter-item "><a href="building/build-install-distribution-artifacts.html"><strong aria-hidden="true">1.4.</strong> Distribution artifacts</a></li><li class="chapter-item "><a href="building/compiler-documenting.html"><strong aria-hidden="true">1.5.</strong> Building Documentation</a></li><li class="chapter-item "><a href="rustdoc.html"><strong aria-hidden="true">1.6.</strong> Rustdoc overview</a></li><li class="chapter-item "><a href="building/new-target.html"><strong aria-hidden="true">1.7.</strong> Adding a new target</a></li><li class="chapter-item "><a href="building/optimized-build.html"><strong aria-hidden="true">1.8.</strong> Optimized build</a></li></ol></li><li class="chapter-item "><a href="tests/intro.html"><strong aria-hidden="true">2.</strong> Testing the compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tests/running.html"><strong aria-hidden="true">2.1.</strong> Running tests</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tests/docker.html"><strong aria-hidden="true">2.1.1.</strong> Testing with Docker</a></li><li class="chapter-item "><a href="tests/ci.html"><strong aria-hidden="true">2.1.2.</strong> Testing with CI</a></li></ol></li><li class="chapter-item "><a href="tests/adding.html"><strong aria-hidden="true">2.2.</strong> Adding new tests</a></li><li class="chapter-item "><a href="tests/compiletest.html"><strong aria-hidden="true">2.3.</strong> Compiletest</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tests/ui.html"><strong aria-hidden="true">2.3.1.</strong> UI tests</a></li><li class="chapter-item "><a href="tests/headers.html"><strong aria-hidden="true">2.3.2.</strong> Test headers</a></li></ol></li><li class="chapter-item "><a href="tests/integration.html"><strong aria-hidden="true">2.4.</strong> Integration testing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tests/crater.html"><strong aria-hidden="true">2.4.1.</strong> Crater</a></li><li class="chapter-item "><a href="tests/fuchsia.html"><strong aria-hidden="true">2.4.2.</strong> Fuchsia</a></li><li class="chapter-item "><a href="tests/rust-for-linux.html"><strong aria-hidden="true">2.4.3.</strong> Rust for Linux</a></li></ol></li><li class="chapter-item "><a href="tests/perf.html"><strong aria-hidden="true">2.5.</strong> Performance testing</a></li><li class="chapter-item "><a href="tests/suggest-tests.html"><strong aria-hidden="true">2.6.</strong> Suggest tests tool</a></li></ol></li><li class="chapter-item "><a href="compiler-debugging.html"><strong aria-hidden="true">3.</strong> Debugging the compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tracing.html"><strong aria-hidden="true">3.1.</strong> Using the tracing/logging instrumentation</a></li></ol></li><li class="chapter-item "><a href="profiling.html"><strong aria-hidden="true">4.</strong> Profiling the compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="profiling/with_perf.html"><strong aria-hidden="true">4.1.</strong> with the linux perf tool</a></li><li class="chapter-item "><a href="profiling/wpa_profiling.html"><strong aria-hidden="true">4.2.</strong> with Windows Performance Analyzer</a></li></ol></li><li class="chapter-item "><a href="crates-io.html"><strong aria-hidden="true">5.</strong> crates.io Dependencies</a></li><li class="chapter-item affix "><li class="part-title">Contributing to Rust</li><li class="chapter-item "><a href="contributing.html"><strong aria-hidden="true">6.</strong> Contribution Procedures</a></li><li class="chapter-item "><a href="compiler-team.html"><strong aria-hidden="true">7.</strong> About the compiler team</a></li><li class="chapter-item "><a href="git.html"><strong aria-hidden="true">8.</strong> Using Git</a></li><li class="chapter-item "><a href="rustbot.html"><strong aria-hidden="true">9.</strong> Mastering @rustbot</a></li><li class="chapter-item "><a href="walkthrough.html"><strong aria-hidden="true">10.</strong> Walkthrough: a typical contribution</a></li><li class="chapter-item "><a href="implementing_new_features.html"><strong aria-hidden="true">11.</strong> Implementing new language features</a></li><li class="chapter-item "><a href="stability.html"><strong aria-hidden="true">12.</strong> Stability attributes</a></li><li class="chapter-item "><a href="stabilization_guide.html"><strong aria-hidden="true">13.</strong> Stabilizing Features</a></li><li class="chapter-item "><a href="feature-gates.html"><strong aria-hidden="true">14.</strong> Feature Gates</a></li><li class="chapter-item "><a href="conventions.html"><strong aria-hidden="true">15.</strong> Coding conventions</a></li><li class="chapter-item "><a href="bug-fix-procedure.html"><strong aria-hidden="true">16.</strong> Procedures for Breaking Changes</a></li><li class="chapter-item "><a href="external-repos.html"><strong aria-hidden="true">17.</strong> Using external repositories</a></li><li class="chapter-item "><a href="fuzzing.html"><strong aria-hidden="true">18.</strong> Fuzzing</a></li><li class="chapter-item "><a href="notification-groups/about.html"><strong aria-hidden="true">19.</strong> Notification groups</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="notification-groups/apple.html"><strong aria-hidden="true">19.1.</strong> Apple</a></li><li class="chapter-item "><a href="notification-groups/arm.html"><strong aria-hidden="true">19.2.</strong> ARM</a></li><li class="chapter-item "><a href="notification-groups/cleanup-crew.html"><strong aria-hidden="true">19.3.</strong> Cleanup Crew</a></li><li class="chapter-item "><a href="notification-groups/llvm.html"><strong aria-hidden="true">19.4.</strong> LLVM</a></li><li class="chapter-item "><a href="notification-groups/risc-v.html"><strong aria-hidden="true">19.5.</strong> RISC-V</a></li><li class="chapter-item "><a href="notification-groups/windows.html"><strong aria-hidden="true">19.6.</strong> Windows</a></li><li class="chapter-item "><a href="notification-groups/rust-for-linux.html"><strong aria-hidden="true">19.7.</strong> Rust for Linux</a></li></ol></li><li class="chapter-item "><a href="licenses.html"><strong aria-hidden="true">20.</strong> Licenses</a></li><li class="chapter-item "><a href="guides/editions.html"><strong aria-hidden="true">21.</strong> Editions</a></li><li class="chapter-item affix "><li class="part-title">Bootstrapping</li><li class="chapter-item "><a href="building/bootstrapping/intro.html"><strong aria-hidden="true">22.</strong> Prologue</a></li><li class="chapter-item "><a href="building/bootstrapping/what-bootstrapping-does.html"><strong aria-hidden="true">23.</strong> What Bootstrapping does</a></li><li class="chapter-item "><a href="building/bootstrapping/how-bootstrap-does-it.html"><strong aria-hidden="true">24.</strong> How Bootstrap does it</a></li><li class="chapter-item affix "><li class="part-title">High-level Compiler Architecture</li><li class="chapter-item "><a href="part-2-intro.html"><strong aria-hidden="true">25.</strong> Prologue</a></li><li class="chapter-item "><a href="overview.html"><strong aria-hidden="true">26.</strong> Overview of the compiler</a></li><li class="chapter-item "><a href="compiler-src.html"><strong aria-hidden="true">27.</strong> The compiler source code</a></li><li class="chapter-item "><a href="query.html"><strong aria-hidden="true">28.</strong> Queries: demand-driven compilation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="queries/query-evaluation-model-in-detail.html"><strong aria-hidden="true">28.1.</strong> The Query Evaluation Model in Detail</a></li><li class="chapter-item "><a href="queries/incremental-compilation.html"><strong aria-hidden="true">28.2.</strong> Incremental compilation</a></li><li class="chapter-item "><a href="queries/incremental-compilation-in-detail.html"><strong aria-hidden="true">28.3.</strong> Incremental compilation In Detail</a></li><li class="chapter-item "><a href="incrcomp-debugging.html"><strong aria-hidden="true">28.4.</strong> Debugging and Testing</a></li><li class="chapter-item "><a href="salsa.html"><strong aria-hidden="true">28.5.</strong> Salsa</a></li></ol></li><li class="chapter-item "><a href="memory.html"><strong aria-hidden="true">29.</strong> Memory Management in Rustc</a></li><li class="chapter-item "><a href="serialization.html"><strong aria-hidden="true">30.</strong> Serialization in Rustc</a></li><li class="chapter-item "><a href="parallel-rustc.html"><strong aria-hidden="true">31.</strong> Parallel Compilation</a></li><li class="chapter-item "><a href="rustdoc-internals.html"><strong aria-hidden="true">32.</strong> Rustdoc internals</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rustdoc-internals/search.html"><strong aria-hidden="true">32.1.</strong> Search</a></li></ol></li><li class="chapter-item "><li class="part-title">Source Code Representation</li><li class="chapter-item "><a href="part-3-intro.html"><strong aria-hidden="true">33.</strong> Prologue</a></li><li class="chapter-item "><a href="cli.html"><strong aria-hidden="true">34.</strong> Command-line arguments</a></li><li class="chapter-item "><a href="rustc-driver.html"><strong aria-hidden="true">35.</strong> rustc_driver and rustc_interface</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rustc-driver-interacting-with-the-ast.html"><strong aria-hidden="true">35.1.</strong> Example: Type checking</a></li><li class="chapter-item "><a href="rustc-driver-getting-diagnostics.html"><strong aria-hidden="true">35.2.</strong> Example: Getting diagnostics</a></li></ol></li><li class="chapter-item "><a href="syntax-intro.html"><strong aria-hidden="true">36.</strong> Syntax and the AST</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="the-parser.html"><strong aria-hidden="true">36.1.</strong> Lexing and Parsing</a></li><li class="chapter-item "><a href="macro-expansion.html"><strong aria-hidden="true">36.2.</strong> Macro expansion</a></li><li class="chapter-item "><a href="name-resolution.html"><strong aria-hidden="true">36.3.</strong> Name resolution</a></li><li class="chapter-item "><a href="attributes.html"><strong aria-hidden="true">36.4.</strong> Attributes</a></li><li class="chapter-item "><a href="test-implementation.html"><strong aria-hidden="true">36.5.</strong> #[test] Implementation</a></li><li class="chapter-item "><a href="panic-implementation.html"><strong aria-hidden="true">36.6.</strong> Panic Implementation</a></li><li class="chapter-item "><a href="ast-validation.html"><strong aria-hidden="true">36.7.</strong> AST Validation</a></li><li class="chapter-item "><a href="feature-gate-ck.html"><strong aria-hidden="true">36.8.</strong> Feature Gate Checking</a></li><li class="chapter-item "><a href="lang-items.html"><strong aria-hidden="true">36.9.</strong> Lang Items</a></li></ol></li><li class="chapter-item "><a href="hir.html"><strong aria-hidden="true">37.</strong> The HIR (High-level IR)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ast-lowering.html"><strong aria-hidden="true">37.1.</strong> Lowering AST to HIR</a></li><li class="chapter-item "><a href="hir-debugging.html"><strong aria-hidden="true">37.2.</strong> Debugging</a></li></ol></li><li class="chapter-item "><a href="thir.html"><strong aria-hidden="true">38.</strong> The THIR (Typed High-level IR)</a></li><li class="chapter-item "><a href="mir/index.html"><strong aria-hidden="true">39.</strong> The MIR (Mid-level IR)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="mir/construction.html"><strong aria-hidden="true">39.1.</strong> MIR construction</a></li><li class="chapter-item "><a href="mir/visitor.html"><strong aria-hidden="true">39.2.</strong> MIR visitor and traversal</a></li><li class="chapter-item "><a href="mir/passes.html"><strong aria-hidden="true">39.3.</strong> MIR passes: getting the MIR for a function</a></li></ol></li><li class="chapter-item "><a href="identifiers.html"><strong aria-hidden="true">40.</strong> Identifiers in the compiler</a></li><li class="chapter-item "><a href="closure.html"><strong aria-hidden="true">41.</strong> Closure expansion</a></li><li class="chapter-item "><a href="asm.html"><strong aria-hidden="true">42.</strong> Inline assembly</a></li><li class="chapter-item affix "><li class="part-title">Analysis</li><li class="chapter-item "><a href="part-4-intro.html"><strong aria-hidden="true">43.</strong> Prologue</a></li><li class="chapter-item "><a href="generic_parameters_summary.html"><strong aria-hidden="true">44.</strong> Generic parameter definitions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="what_is_ty_generics.html"><strong aria-hidden="true">44.1.</strong> What is ty::Generics</a></li><li class="chapter-item "><a href="early-late-bound-params/early-late-bound-summary.html"><strong aria-hidden="true">44.2.</strong> Early vs Late bound parameters</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="early-late-bound-params/early-late-bound-implementation-nuances.html"><strong aria-hidden="true">44.2.1.</strong> Implementation nuances of early/late bound parameters</a></li><li class="chapter-item "><a href="early-late-bound-params/turbofishing-and-early-late-bound.html"><strong aria-hidden="true">44.2.2.</strong> Interactions with turbofishing</a></li></ol></li></ol></li><li class="chapter-item "><a href="ty.html"><strong aria-hidden="true">45.</strong> The ty module: representing types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ty_module/generic_arguments.html"><strong aria-hidden="true">45.1.</strong> ADTs and Generic Arguments</a></li><li class="chapter-item "><a href="ty_module/param_ty_const_regions.html"><strong aria-hidden="true">45.2.</strong> Parameter types/consts/regions</a></li><li class="chapter-item "><a href="ty_module/early_binder.html"><strong aria-hidden="true">45.3.</strong> EarlyBinder and instantiating parameters</a></li><li class="chapter-item "><a href="ty_module/binders.html"><strong aria-hidden="true">45.4.</strong> Binder and Higher ranked regions</a></li><li class="chapter-item "><a href="ty_module/instantiating_binders.html"><strong aria-hidden="true">45.5.</strong> Instantiating binders</a></li><li class="chapter-item "><a href="constants.html"><strong aria-hidden="true">45.6.</strong> Constants in the type system</a></li></ol></li><li class="chapter-item "><a href="ty-fold.html"><strong aria-hidden="true">46.</strong> TypeFolder and TypeFoldable</a></li><li class="chapter-item "><a href="param_env/param_env_summary.html"><strong aria-hidden="true">47.</strong> Parameter Environments</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="param_env/param_env_what_is_it.html"><strong aria-hidden="true">47.1.</strong> What is it?</a></li><li class="chapter-item "><a href="param_env/param_env_construction_internals.html"><strong aria-hidden="true">47.2.</strong> How are ParamEnv's constructed internally</a></li><li class="chapter-item "><a href="param_env/param_env_acquisition.html"><strong aria-hidden="true">47.3.</strong> Which ParamEnv do I use?</a></li></ol></li><li class="chapter-item "><a href="type-inference.html"><strong aria-hidden="true">48.</strong> Type inference</a></li><li class="chapter-item "><a href="traits/resolution.html"><strong aria-hidden="true">49.</strong> Trait solving</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/hrtb.html"><strong aria-hidden="true">49.1.</strong> Higher-ranked trait bounds</a></li><li class="chapter-item "><a href="traits/caching.html"><strong aria-hidden="true">49.2.</strong> Caching subtleties</a></li><li class="chapter-item "><a href="traits/implied-bounds.html"><strong aria-hidden="true">49.3.</strong> Implied bounds</a></li><li class="chapter-item "><a href="traits/specialization.html"><strong aria-hidden="true">49.4.</strong> Specialization</a></li><li class="chapter-item "><a href="traits/chalk.html"><strong aria-hidden="true">49.5.</strong> Chalk-based trait solving</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="traits/lowering-to-logic.html"><strong aria-hidden="true">49.5.1.</strong> Lowering to logic</a></li><li class="chapter-item "><a href="traits/goals-and-clauses.html"><strong aria-hidden="true">49.5.2.</strong> Goals and clauses</a></li><li class="chapter-item "><a href="traits/canonical-queries.html"><strong aria-hidden="true">49.5.3.</strong> Canonical queries</a></li><li class="chapter-item "><a href="traits/canonicalization.html"><strong aria-hidden="true">49.5.4.</strong> Canonicalization</a></li></ol></li><li class="chapter-item "><a href="solve/trait-solving.html"><strong aria-hidden="true">49.6.</strong> Next-gen trait solving</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="solve/invariants.html"><strong aria-hidden="true">49.6.1.</strong> Invariants of the type system</a></li><li class="chapter-item "><a href="solve/the-solver.html"><strong aria-hidden="true">49.6.2.</strong> The solver</a></li><li class="chapter-item "><a href="solve/canonicalization.html"><strong aria-hidden="true">49.6.3.</strong> Canonicalization</a></li><li class="chapter-item "><a href="solve/coinduction.html"><strong aria-hidden="true">49.6.4.</strong> Coinduction</a></li><li class="chapter-item "><a href="solve/caching.html"><strong aria-hidden="true">49.6.5.</strong> Caching</a></li><li class="chapter-item "><a href="solve/proof-trees.html"><strong aria-hidden="true">49.6.6.</strong> Proof trees</a></li><li class="chapter-item "><a href="solve/normalization.html"><strong aria-hidden="true">49.6.7.</strong> Normalization</a></li><li class="chapter-item "><a href="solve/opaque-types.html"><strong aria-hidden="true">49.6.8.</strong> Opaque types</a></li><li class="chapter-item "><a href="solve/significant-changes.html"><strong aria-hidden="true">49.6.9.</strong> Significant changes and quirks</a></li></ol></li><li class="chapter-item "><a href="traits/unsize.html"><strong aria-hidden="true">49.7.</strong> Unsize and CoerceUnsized traits</a></li></ol></li><li class="chapter-item "><a href="type-checking.html"><strong aria-hidden="true">50.</strong> Type checking</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="method-lookup.html"><strong aria-hidden="true">50.1.</strong> Method Lookup</a></li><li class="chapter-item "><a href="variance.html"><strong aria-hidden="true">50.2.</strong> Variance</a></li><li class="chapter-item "><a href="opaque-types-type-alias-impl-trait.html"><strong aria-hidden="true">50.3.</strong> Opaque Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="opaque-types-impl-trait-inference.html"><strong aria-hidden="true">50.3.1.</strong> Inference details</a></li><li class="chapter-item "><a href="return-position-impl-trait-in-trait.html"><strong aria-hidden="true">50.3.2.</strong> Return Position Impl Trait In Trait</a></li><li class="chapter-item "><a href="borrow_check/opaque-types-region-inference-restrictions.html"><strong aria-hidden="true">50.3.3.</strong> Region inference restrictions</a></li></ol></li></ol></li><li class="chapter-item "><a href="effects.html"><strong aria-hidden="true">51.</strong> Effect checking</a></li><li class="chapter-item "><a href="pat-exhaustive-checking.html"><strong aria-hidden="true">52.</strong> Pattern and Exhaustiveness Checking</a></li><li class="chapter-item "><a href="unsafety-checking.html"><strong aria-hidden="true">53.</strong> Unsafety Checking</a></li><li class="chapter-item "><a href="mir/dataflow.html"><strong aria-hidden="true">54.</strong> MIR dataflow</a></li><li class="chapter-item "><a href="mir/drop-elaboration.html"><strong aria-hidden="true">55.</strong> Drop elaboration</a></li><li class="chapter-item "><a href="borrow_check.html"><strong aria-hidden="true">56.</strong> The borrow checker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrow_check/moves_and_initialization.html"><strong aria-hidden="true">56.1.</strong> Tracking moves and initialization</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrow_check/moves_and_initialization/move_paths.html"><strong aria-hidden="true">56.1.1.</strong> Move paths</a></li></ol></li><li class="chapter-item "><a href="borrow_check/type_check.html"><strong aria-hidden="true">56.2.</strong> MIR type checker</a></li><li class="chapter-item "><a href="borrow_check/drop_check.html"><strong aria-hidden="true">56.3.</strong> Drop check</a></li><li class="chapter-item "><a href="borrow_check/region_inference.html"><strong aria-hidden="true">56.4.</strong> Region inference</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="borrow_check/region_inference/constraint_propagation.html"><strong aria-hidden="true">56.4.1.</strong> Constraint propagation</a></li><li class="chapter-item "><a href="borrow_check/region_inference/lifetime_parameters.html"><strong aria-hidden="true">56.4.2.</strong> Lifetime parameters</a></li><li class="chapter-item "><a href="borrow_check/region_inference/member_constraints.html"><strong aria-hidden="true">56.4.3.</strong> Member constraints</a></li><li class="chapter-item "><a href="borrow_check/region_inference/placeholders_and_universes.html"><strong aria-hidden="true">56.4.4.</strong> Placeholders and universes</a></li><li class="chapter-item "><a href="borrow_check/region_inference/closure_constraints.html"><strong aria-hidden="true">56.4.5.</strong> Closure constraints</a></li><li class="chapter-item "><a href="borrow_check/region_inference/error_reporting.html"><strong aria-hidden="true">56.4.6.</strong> Error reporting</a></li></ol></li><li class="chapter-item "><a href="borrow_check/two_phase_borrows.html"><strong aria-hidden="true">56.5.</strong> Two-phase-borrows</a></li></ol></li><li class="chapter-item "><a href="diagnostics.html"><strong aria-hidden="true">57.</strong> Errors and Lints</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="diagnostics/diagnostic-structs.html"><strong aria-hidden="true">57.1.</strong> Diagnostic and subdiagnostic structs</a></li><li class="chapter-item "><a href="diagnostics/translation.html"><strong aria-hidden="true">57.2.</strong> Translation</a></li><li class="chapter-item "><a href="diagnostics/lintstore.html"><strong aria-hidden="true">57.3.</strong> LintStore</a></li><li class="chapter-item "><a href="diagnostics/error-codes.html"><strong aria-hidden="true">57.4.</strong> Error codes</a></li><li class="chapter-item "><a href="diagnostics/diagnostic-items.html"><strong aria-hidden="true">57.5.</strong> Diagnostic items</a></li><li class="chapter-item "><a href="diagnostics/error-guaranteed.html"><strong aria-hidden="true">57.6.</strong> ErrorGuaranteed</a></li></ol></li><li class="chapter-item "><li class="part-title">MIR to Binaries</li><li class="chapter-item "><a href="part-5-intro.html"><strong aria-hidden="true">58.</strong> Prologue</a></li><li class="chapter-item "><a href="mir/optimizations.html"><strong aria-hidden="true">59.</strong> MIR optimizations</a></li><li class="chapter-item "><a href="mir/debugging.html"><strong aria-hidden="true">60.</strong> Debugging</a></li><li class="chapter-item "><a href="const-eval.html"><strong aria-hidden="true">61.</strong> Constant evaluation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="const-eval/interpret.html"><strong aria-hidden="true">61.1.</strong> Interpreter</a></li></ol></li><li class="chapter-item "><a href="backend/monomorph.html"><strong aria-hidden="true">62.</strong> Monomorphization</a></li><li class="chapter-item "><a href="backend/lowering-mir.html"><strong aria-hidden="true">63.</strong> Lowering MIR</a></li><li class="chapter-item "><a href="backend/codegen.html"><strong aria-hidden="true">64.</strong> Code Generation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="backend/updating-llvm.html"><strong aria-hidden="true">64.1.</strong> Updating LLVM</a></li><li class="chapter-item "><a href="backend/debugging.html"><strong aria-hidden="true">64.2.</strong> Debugging LLVM</a></li><li class="chapter-item "><a href="backend/backend-agnostic.html"><strong aria-hidden="true">64.3.</strong> Backend Agnostic Codegen</a></li><li class="chapter-item "><a href="backend/implicit-caller-location.html"><strong aria-hidden="true">64.4.</strong> Implicit Caller Location</a></li></ol></li><li class="chapter-item "><a href="backend/libs-and-metadata.html"><strong aria-hidden="true">65.</strong> Libraries and Metadata</a></li><li class="chapter-item "><a href="profile-guided-optimization.html"><strong aria-hidden="true">66.</strong> Profile-guided Optimization</a></li><li class="chapter-item expanded "><a href="llvm-coverage-instrumentation.html" class="active"><strong aria-hidden="true">67.</strong> LLVM Source-Based Code Coverage</a></li><li class="chapter-item "><a href="sanitizers.html"><strong aria-hidden="true">68.</strong> Sanitizers Support</a></li><li class="chapter-item "><a href="debugging-support-in-rustc.html"><strong aria-hidden="true">69.</strong> Debugging support in the Rust compiler</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="appendix/background.html">Appendix A: Background topics</a></li><li class="chapter-item affix "><a href="appendix/glossary.html">Appendix B: Glossary</a></li><li class="chapter-item affix "><a href="appendix/code-index.html">Appendix C: Code Index</a></li><li class="chapter-item affix "><a href="appendix/compiler-lecture.html">Appendix D: Compiler Lecture Series</a></li><li class="chapter-item affix "><a href="appendix/bibliography.html">Appendix E: Bibliography</a></li><li class="chapter-item affix "><a href="appendix/humorust.html">Appendix Z: HumorRust</a></li><li class="spacer"></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Compiler Development Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rustc-dev-guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rustc-dev-guide/edit/master/src/llvm-coverage-instrumentation.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="llvm-source-based-code-coverage"><a class="header" href="#llvm-source-based-code-coverage">LLVM Source-Based Code Coverage</a></h1>
<ul>
<li><a href="#recommended-configtoml-settings">Recommended <code>config.toml</code> settings</a></li>
<li><a href="#rust-symbol-mangling">Rust symbol mangling</a></li>
<li><a href="#components-of-llvm-coverage-instrumentation-in-rustc">Components of LLVM Coverage Instrumentation in <code>rustc</code></a>
<ul>
<li><a href="#llvm-runtime-dependency">LLVM Runtime Dependency</a></li>
<li><a href="#mir-pass-instrumentcoverage">MIR Pass: <code>InstrumentCoverage</code></a></li>
<li><a href="#counter-injection-and-coverage-map-pre-staging">Counter Injection and Coverage Map Pre-staging</a></li>
<li><a href="#coverage-map-generation">Coverage Map Generation</a></li>
</ul>
</li>
<li><a href="#testing-llvm-coverage">Testing LLVM Coverage</a></li>
<li><a href="#implementation-details-of-the-instrumentcoverage-mir-pass">Implementation Details of the <code>InstrumentCoverage</code> MIR Pass</a>
<ul>
<li><a href="#the-coveragegraph">The <code>CoverageGraph</code></a></li>
<li><a href="#coveragespans"><code>CoverageSpans</code></a></li>
<li><a href="#make_bcb_counters"><code>make_bcb_counters()</code></a></li>
</ul>
</li>
</ul>
<p><code>rustc</code> supports detailed source-based code and test coverage analysis
with a command line option (<code>-C instrument-coverage</code>) that instruments Rust
libraries and binaries with additional instructions and data, at compile time.</p>
<p>The coverage instrumentation injects calls to the LLVM intrinsic instruction
<a href="https://llvm.org/docs/LangRef.html#llvm-instrprof-increment-intrinsic"><code>llvm.instrprof.increment</code></a> at code branches
(based on a MIR-based control flow analysis), and LLVM converts these to
instructions that increment static counters, when executed. The LLVM coverage
instrumentation also requires a <a href="https://llvm.org/docs/CoverageMappingFormat.html">Coverage Map</a> that encodes source metadata,
mapping counter IDs--directly and indirectly--to the file locations (with
start and end line and column).</p>
<p>Rust libraries, with or without coverage instrumentation, can be linked into
instrumented binaries. When the program is executed and cleanly terminates,
LLVM libraries write the final counter values to a file (<code>default.profraw</code> or
a custom file set through environment variable <code>LLVM_PROFILE_FILE</code>).</p>
<p>Developers use existing LLVM coverage analysis tools to decode <code>.profraw</code>
files, with corresponding Coverage Maps (from matching binaries that produced
them), and generate various reports for analysis, for example:</p>
<p><img alt="Screenshot of sample `llvm-cov show` result, for function add_quoted_string"
 src="img/llvm-cov-show-01.png" class="center"/>
<br/></p>
<p>Detailed instructions and examples are documented in the
<a href="https://doc.rust-lang.org/nightly/rustc/instrument-coverage.html">rustc book</a>.</p>
<h2 id="recommended-configtoml-settings"><a class="header" href="#recommended-configtoml-settings">Recommended <code>config.toml</code> settings</a></h2>
<p>When working on the coverage instrumentation code, it is usually necessary to
<strong>enable the profiler runtime</strong> by setting <code>profiler = true</code> in <code>[build]</code>.
This allows the compiler to produce instrumented binaries, and makes it possible
to run the full coverage test suite.</p>
<p>Enabling debug assertions in the compiler and in LLVM is recommended, but not
mandatory.</p>
<pre><code class="language-toml"># Similar to the &quot;compiler&quot; profile, but also enables debug assertions in LLVM.
# These assertions can detect malformed coverage mappings in some cases.
profile = &quot;codegen&quot;

[build]
# IMPORTANT: This tells the build system to build the LLVM profiler runtime.
# Without it, the compiler can't produce coverage-instrumented binaries,
# and many of the coverage tests will be skipped.
profiler = true

[rust]
# Enable debug assertions in the compiler.
debug-assertions = true
</code></pre>
<h2 id="rust-symbol-mangling"><a class="header" href="#rust-symbol-mangling">Rust symbol mangling</a></h2>
<p><code>-C instrument-coverage</code> automatically enables Rust symbol mangling <code>v0</code> (as
if the user specified <code>-C symbol-mangling-version=v0</code> option when invoking
<code>rustc</code>) to ensure consistent and reversible name mangling. This has two
important benefits:</p>
<ol>
<li>LLVM coverage tools can analyze coverage over multiple runs, including some
changes to source code; so mangled names must be consistent across compilations.</li>
<li>LLVM coverage reports can report coverage by function, and even separates
out the coverage counts of each unique instantiation of a generic function,
if invoked with multiple type substitution variations.</li>
</ol>
<h2 id="components-of-llvm-coverage-instrumentation-in-rustc"><a class="header" href="#components-of-llvm-coverage-instrumentation-in-rustc">Components of LLVM Coverage Instrumentation in <code>rustc</code></a></h2>
<h3 id="llvm-runtime-dependency"><a class="header" href="#llvm-runtime-dependency">LLVM Runtime Dependency</a></h3>
<p>Coverage data is only generated by running the executable Rust program. <code>rustc</code>
statically links coverage-instrumented binaries with LLVM runtime code
(<a href="https://github.com/llvm/llvm-project/tree/main/compiler-rt/lib/profile">compiler-rt</a>) that implements program hooks
(such as an <code>exit</code> hook) to write the counter values to the <code>.profraw</code> file.</p>
<p>In the <code>rustc</code> source tree,
<code>library/profiler_builtins</code> bundles the LLVM <code>compiler-rt</code> code into a Rust library crate.
Note that when building <code>rustc</code>,
<code>profiler_builtins</code> is only included when <code>build.profiler = true</code> is set in <code>config.toml</code>.</p>
<p>When compiling with <code>-C instrument-coverage</code>,
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_metadata/creader/struct.CrateLoader.html#method.postprocess"><code>CrateLoader::postprocess()</code></a> dynamically loads
<code>profiler_builtins</code> by calling <code>inject_profiler_runtime()</code>.</p>
<h3 id="mir-pass-instrumentcoverage"><a class="header" href="#mir-pass-instrumentcoverage">MIR Pass: <code>InstrumentCoverage</code></a></h3>
<p>Coverage instrumentation is performed on the MIR with a <a href="mir/passes.html">MIR pass</a>
called <a href="https://github.com/rust-lang/rust/tree/master/compiler/rustc_mir_transform/src/coverage"><code>InstrumentCoverage</code></a>. This MIR pass analyzes
the control flow graph (CFG)--represented by MIR <code>BasicBlock</code>s--to identify
code branches, attaches <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/coverage/struct.FunctionCoverageInfo.html"><code>FunctionCoverageInfo</code></a> to the function's body,
and injects additional <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/enum.StatementKind.html#variant.Coverage"><code>Coverage</code></a> statements into the
<code>BasicBlock</code>s.</p>
<p>A MIR <code>Coverage</code> statement is a virtual instruction that indicates a counter
should be incremented when its adjacent statements are executed, to count
a span of code (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/coverage/struct.CodeRegion.html"><code>CodeRegion</code></a>). It counts the number of times a
branch is executed, and is referred to by coverage mappings in the function's
coverage-info struct.</p>
<p>Note that many coverage counters will <em>not</em> be converted into
physical counters (or any other executable instructions) in the final binary.
Some of them will be (see <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/coverage/enum.CoverageKind.html#variant.CounterIncrement"><code>CoverageKind::CounterIncrement</code></a>),
but other counters can be computed on the fly, when generating a coverage
report, by mapping a <code>CodeRegion</code> to a coverage-counter <em>expression</em>.</p>
<p>As an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_func(flag: bool) {
    // increment Counter(1)
    ...
    if flag {
        // increment Counter(2)
        ...
    } else {
        // count = Expression(1) = Counter(1) - Counter(2)
        ...
    }
    // count = Expression(2) = Counter(1) + Zero
    //     or, alternatively, Expression(2) = Counter(2) + Expression(1)
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>In this example, four contiguous code regions are counted while only
incrementing two counters.</p>
<p>CFG analysis is used to not only determine <em>where</em> the branches are, for
conditional expressions like <code>if</code>, <code>else</code>, <code>match</code>, and <code>loop</code>, but also to
determine where expressions can be used in place of physical counters.</p>
<p>The advantages of optimizing coverage through expressions are more pronounced
with loops. Loops generally include at least one conditional branch that
determines when to break out of a loop (a <code>while</code> condition, or an <code>if</code> or
<code>match</code> with a <code>break</code>). In MIR, this is typically lowered to a <code>SwitchInt</code>,
with one branch to stay in the loop, and another branch to break out of the
loop. The branch that breaks out will almost always execute less often,
so <code>InstrumentCoverage</code> chooses to add a <code>CounterIncrement</code> to that branch, and
uses an expression (<code>Counter(loop) - Counter(break)</code>) for the branch that
continues.</p>
<p>The <code>InstrumentCoverage</code> MIR pass is documented in
<a href="#implementation-details-of-the-instrumentcoverage-mir-pass">more detail below</a>.</p>
<h3 id="counter-injection-and-coverage-map-pre-staging"><a class="header" href="#counter-injection-and-coverage-map-pre-staging">Counter Injection and Coverage Map Pre-staging</a></h3>
<p>When the compiler enters <a href="backend/lowering-mir.html">the Codegen phase</a>, with a
coverage-enabled MIR, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/mir/struct.FunctionCx.html#method.codegen_statement"><code>codegen_statement()</code></a> converts each
MIR <code>Statement</code> into some backend-specific action or instruction.
<code>codegen_statement()</code> forwards <code>Coverage</code> statements to
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/mir/struct.FunctionCx.html#method.codegen_coverage"><code>codegen_coverage()</code></a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    pub fn codegen_statement(&amp;mut self, mut bx: Bx, statement: &amp;mir::Statement&lt;'tcx&gt;) -&gt; Bx {
        ...
        match statement.kind {
            ...
            mir::StatementKind::Coverage(box ref coverage) =&gt; {
                self.codegen_coverage(bx, coverage, statement.source_info.scope);
            }
<span class="boring">}
</span></code></pre></pre>
<p><code>codegen_coverage()</code> handles inlined statements and then forwards the coverage
statement to <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/builder/struct.Builder.html#method.add_coverage"><code>Builder::add_coverage</code></a>, which handles each <code>CoverageKind</code> as
follows:</p>
<ul>
<li>For both <code>CounterIncrement</code> and <code>ExpressionUsed</code>, the underlying counter or
expression ID is passed through to the corresponding <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/coverageinfo/map_data/struct.FunctionCoverage.html"><code>FunctionCoverage</code></a>
struct to indicate that the corresponding regions of code were not removed
by MIR optimizations.</li>
<li>For <code>CoverageKind::CounterIncrement</code>s, an instruction is injected in the backend
IR to increment the physical counter, by calling the <code>BuilderMethod</code>
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/traits/trait.BuilderMethods.html#tymethod.instrprof_increment"><code>instrprof_increment()</code></a>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn add_coverage(&amp;mut self, instance: Instance&lt;'tcx&gt;, coverage: &amp;Coverage) {
        ...
        let Coverage { kind } = coverage;
        match *kind {
            CoverageKind::CounterIncrement { id } =&gt; {
                func_coverage.mark_counter_id_seen(id);
                ...
                bx.instrprof_increment(fn_name, hash, num_counters, index);
            }
            CoverageKind::ExpressionUsed { id } =&gt; {
                func_coverage.mark_expression_id_seen(id);
            }
        }
    }
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The function name <code>instrprof_increment()</code> is taken from the LLVM intrinsic
call of the same name (<a href="https://llvm.org/docs/LangRef.html#llvm-instrprof-increment-intrinsic"><code>llvm.instrprof.increment</code></a>),
and uses the same arguments and types; but note that, up to and through this
stage (even though modeled after LLVM's implementation for code coverage
instrumentation), the data and instructions are not strictly LLVM-specific.</p>
<p>But since LLVM is the only Rust-supported backend with the tooling to
process this form of coverage instrumentation, the backend for <code>Coverage</code>
statements is only implemented for LLVM, at this time.</p>
</blockquote>
<h3 id="coverage-map-generation"><a class="header" href="#coverage-map-generation">Coverage Map Generation</a></h3>
<p>With the instructions to increment counters now implemented in LLVM IR,
the last remaining step is to inject the LLVM IR variables that hold the
static data for the coverage map.</p>
<p><code>rustc_codegen_llvm</code>'s <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/base/fn.compile_codegen_unit.html"><code>compile_codegen_unit()</code></a> calls
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/context/struct.CodegenCx.html#method.coverageinfo_finalize"><code>coverageinfo_finalize()</code></a>,
which delegates its implementation to the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/coverageinfo/mapgen/fn.finalize.html"><code>rustc_codegen_llvm::coverageinfo::mapgen</code></a> module.</p>
<p>For each function <code>Instance</code> (code-generated from MIR, including multiple
instances of the same MIR for generic functions that have different type
substitution combinations), <code>mapgen</code>'s <code>finalize()</code> method queries the
<code>Instance</code>-associated <code>FunctionCoverage</code> for its <code>Counter</code>s, <code>Expression</code>s,
and <code>CodeRegion</code>s; and calls LLVM codegen APIs to generate
properly-configured variables in LLVM IR, according to very specific
details of the <a href="https://llvm.org/docs/CoverageMappingFormat.html"><em>LLVM Coverage Mapping Format</em></a>
(Version 6).<sup class="footnote-reference"><a href="#llvm-and-covmap-versions">1</a></sup></p>
<div class="footnote-definition" id="llvm-and-covmap-versions"><sup class="footnote-definition-label">1</sup>
<p>The Rust compiler (as of <!-- date-check: --> Jul 2023) supports <em>LLVM Coverage Mapping Format</em> 6.
The Rust compiler will automatically use the most up-to-date coverage mapping format
version that is compatible with the compiler's built-in version of LLVM.</p>
</div>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn finalize&lt;'ll, 'tcx&gt;(cx: &amp;CodegenCx&lt;'ll, 'tcx&gt;) {
    ...
    if !tcx.sess.instrument_coverage_except_unused_functions() {
        add_unused_functions(cx);
    }

    let mut function_coverage_map = match cx.coverage_context() {
        Some(ctx) =&gt; ctx.take_function_coverage_map(),
        None =&gt; return,
    };
    ...
    let mut mapgen = CoverageMapGenerator::new();

    for (instance, function_coverage) in function_coverage_map {
        ...
        let coverage_mapping_buffer = llvm::build_byte_buffer(|coverage_mapping_buffer| {
            mapgen.write_coverage_mapping(expressions, counter_regions, coverage_mapping_buffer);
        });
<span class="boring">}
</span></code></pre></pre>
<p><em>code snippet trimmed for brevity</em></p>
<p>One notable first step performed by <code>mapgen::finalize()</code> is the call to
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/coverageinfo/mapgen/fn.add_unused_functions.html"><code>add_unused_functions()</code></a>:</p>
<p>When finalizing the coverage map, <code>FunctionCoverage</code> only has the <code>CodeRegion</code>s
and counters for the functions that went through codegen; such as public
functions and &quot;used&quot; functions (functions referenced by other &quot;used&quot; or public
items). Any other functions (considered unused) were still parsed and processed
through the MIR stage.</p>
<p>The set of unused functions is computed via the set difference of all MIR
<code>DefId</code>s (<code>tcx</code> query <code>mir_keys</code>) minus the codegenned <code>DefId</code>s (<code>tcx</code> query
<code>codegened_and_inlined_items</code>). <code>add_unused_functions()</code> computes the set of
unused functions, queries the <code>tcx</code> for the previously-computed <code>CodeRegions</code>,
for each unused MIR, synthesizes an LLVM function (with no internal statements,
since it will not be called), and adds a new <code>FunctionCoverage</code>, with
<code>Unreachable</code> code regions.</p>
<h2 id="testing-llvm-coverage"><a class="header" href="#testing-llvm-coverage">Testing LLVM Coverage</a></h2>
<p><a href="./tests/compiletest.html#coverage-tests">(See also the compiletest documentation for the <code>tests/coverage</code>
test suite.)</a></p>
<p>Coverage instrumentation in the MIR is validated by a <code>mir-opt</code> test:
<a href="https://github.com/rust-lang/rust/blob/master/tests/mir-opt/instrument_coverage.rs"><code>tests/mir-opt/instrument_coverage.rs</code></a>.</p>
<p>Coverage instrumentation in LLVM IR is validated by the <a href="https://github.com/rust-lang/rust/tree/master/tests/coverage"><code>tests/coverage</code></a>
test suite in <code>coverage-map</code> mode.
These tests compile a test program to LLVM IR assembly, and then
use the <a href="https://github.com/rust-lang/rust/tree/master/src/tools/coverage-dump"><code>src/tools/coverage-dump</code></a> tool to extract and pretty-print the
coverage mappings that would be embedded in the final binary.</p>
<p>End-to-end testing of coverage instrumentation and coverage reporting is
performed by the <a href="https://github.com/rust-lang/rust/tree/master/tests/coverage"><code>tests/coverage</code></a> test suite in <code>coverage-run</code> mode,
and by the <a href="https://github.com/rust-lang/rust/tree/master/tests/coverage-run-rustdoc"><code>tests/coverage-run-rustdoc</code></a> test suite.
These tests compile and run a test program with coverage
instrumentation, then use LLVM tools to convert the coverage data into a
human-readable coverage report.</p>
<blockquote>
<p>Tests in <code>coverage-run</code> mode have an implicit <code>// needs-profiler-support</code>
directive, so they will be skipped if the profiler runtime has not been
<a href="#recommended-configtoml-settings">enabled in <code>config.toml</code></a>.</p>
</blockquote>
<p>Finally, the <a href="https://github.com/rust-lang/rust/tree/master/tests/run-make/coverage-llvmir"><code>coverage-llvmir</code></a> test compiles a simple Rust program
with <code>-C instrument-coverage</code> and compares the compiled program's LLVM IR to
expected LLVM IR instructions and structured data for a coverage-enabled
program, including various checks for Coverage Map-related metadata and the LLVM
intrinsic calls to increment the runtime counters.</p>
<p>Expected results for the <code>coverage</code>, <code>coverage-run-rustdoc</code>,
and <code>mir-opt</code> tests can be refreshed by running:</p>
<pre><code class="language-shell">./x test coverage --bless
./x test coverage-run-rustdoc --bless
./x test tests/mir-opt --bless
</code></pre>
<h2 id="implementation-details-of-the-instrumentcoverage-mir-pass"><a class="header" href="#implementation-details-of-the-instrumentcoverage-mir-pass">Implementation Details of the <code>InstrumentCoverage</code> MIR Pass</a></h2>
<p>The bulk of the implementation of the <code>InstrumentCoverage</code> MIR pass is performed
by the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/struct.Instrumentor.html"><code>Instrumentor</code></a>. For each MIR (each non-const, non-inlined
function, generic, or closure), the <code>Instrumentor</code>'s constructor prepares a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/graph/struct.CoverageGraph.html"><code>CoverageGraph</code></a> and then executes
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/struct.Instrumentor.html#method.inject_counters"><code>inject_counters()</code></a>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Instrumentor::new(&amp;self.name(), tcx, mir_body).inject_counters();
<span class="boring">}
</span></code></pre></pre>
<p>The <code>CoverageGraph</code> is a coverage-specific simplification of the MIR control
flow graph (CFG). Its nodes are <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/graph/struct.BasicCoverageBlock.html"><code>BasicCoverageBlock</code>s</a>, which
encompass one or more sequentially-executed MIR <code>BasicBlock</code>s
(with no internal branching).</p>
<p>Nodes and edges in the graph can have associated <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/counters/enum.BcbCounter.html"><code>BcbCounter</code></a>s, which are
stored in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/counters/struct.CoverageCounters.html"><code>CoverageCounters</code></a>.</p>
<p>The <code>Instrumentor</code>'s <code>inject_counters()</code> uses the <code>CoverageGraph</code> to
compute the best places to inject coverage counters, as MIR <code>Statement</code>s,
with the following steps:</p>
<ol>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/spans/struct.CoverageSpans.html#method.generate_coverage_spans"><code>generate_coverage_spans()</code></a> computes the minimum set of distinct,
non-branching code regions, from the MIR. These <code>CoverageSpan</code>s
represent a span of code that must be counted.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/counters/struct.BcbCounters.html#method.make_bcb_counters"><code>make_bcb_counters()</code></a> generates <code>BcbCounter::Counter</code>s and
<code>BcbCounter::Expression</code>s for each <code>CoverageSpan</code>, plus additional
<em>intermediate expressions</em><sup class="footnote-reference"><a href="#intermediate-expressions">2</a></sup> that are not associated
with any <code>CodeRegion</code>, but
are required to compute a final <code>Expression</code> value for a <code>CodeRegion</code>.</li>
<li>Inject the new counters into the MIR, as new <code>StatementKind::Coverage</code>
statements.</li>
<li>Attach all other necessary coverage information to the function's body as
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/mir/coverage/struct.FunctionCoverageInfo.html"><code>FunctionCoverageInfo</code></a>.</li>
</ol>
<div class="footnote-definition" id="intermediate-expressions"><sup class="footnote-definition-label">2</sup>
<p>Intermediate expressions are sometimes required
because <code>Expression</code>s are limited to binary additions or subtractions. For
example, <code>A + (B - C)</code> might represent an <code>Expression</code> count computed from three
other counters, <code>A</code>, <code>B</code>, and <code>C</code>, but computing that value requires an
intermediate expression for <code>B - C</code>.</p>
</div>
<h3 id="the-coveragegraph"><a class="header" href="#the-coveragegraph">The <code>CoverageGraph</code></a></h3>
<p>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/graph/struct.CoverageGraph.html"><code>CoverageGraph</code></a> is derived from the MIR (<code>mir::Body</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let basic_coverage_blocks = CoverageGraph::from_mir(mir_body);
<span class="boring">}
</span></code></pre></pre>
<p>Like <code>mir::Body</code>, the <code>CoverageGraph</code> is also a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/trait.DirectedGraph.html"><code>DirectedGraph</code></a>. Both graphs represent the function's
fundamental control flow, with many of the same
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/index.html#traits"><code>graph trait</code></a>s, supporting <code>start_node()</code>, <code>num_nodes()</code>,
<code>successors()</code>, <code>predecessors()</code>, and <code>is_dominated_by()</code>.</p>
<p>For anyone that knows how to work with the <a href="mir/index.html">MIR, as a CFG</a>, the
<code>CoverageGraph</code> will be familiar, and can be used in much the same way.
The nodes of the <code>CoverageGraph</code> are <code>BasicCoverageBlock</code>s (BCBs), which
index into an <code>IndexVec</code> of <code>BasicCoverageBlockData</code>. This is analogous
to the MIR CFG of <code>BasicBlock</code>s that index <code>BasicBlockData</code>.</p>
<p>Each <code>BasicCoverageBlockData</code> captures one or more MIR <code>BasicBlock</code>s,
exclusively, and represents the maximal-length sequence of <code>BasicBlocks</code>
without conditional branches.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/graph/struct.CoverageGraph.html#method.compute_basic_coverage_blocks"><code>compute_basic_coverage_blocks()</code></a> builds the
<code>CoverageGraph</code> as a coverage-specific simplification of the MIR CFG. In
contrast with the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/simplify/enum.SimplifyCfg.html"><code>SimplifyCfg</code></a> MIR pass, this step does
not alter the MIR itself, because the <code>CoverageGraph</code> aggressively simplifies
the CFG, and ignores nodes that are not relevant to coverage. For example:</p>
<ul>
<li>The BCB CFG ignores (excludes) branches considered not relevant
to the current coverage solution. It excludes unwind-related code<sup class="footnote-reference"><a href="#78544">3</a></sup>
that is injected by the Rust compiler but has no physical source
code to count, which allows a <code>Call</code>-terminated BasicBlock
to be merged with its successor, within a single BCB.</li>
<li>A <code>Goto</code>-terminated <code>BasicBlock</code> can be merged with its successor
<strong><em>as long as</em></strong> it has the only incoming edge to the successor
<code>BasicBlock</code>.</li>
<li>Some BasicBlock terminators support Rust-specific concerns--like
borrow-checking--that are not relevant to coverage analysis. <code>FalseUnwind</code>,
for example, can be treated the same as a <code>Goto</code> (potentially merged with
its successor into the same BCB).</li>
</ul>
<div class="footnote-definition" id="78544"><sup class="footnote-definition-label">3</sup>
<p>(Note, however, that Issue <a href="https://github.com/rust-lang/rust/issues/78544">#78544</a> considers
providing future support for coverage of programs that intentionally
<code>panic</code>, as an option, with some non-trivial cost.)</p>
</div>
<p>The BCB CFG is critical to simplifying the coverage analysis by ensuring graph path-based
queries (<code>is_dominated_by()</code>, <code>predecessors</code>, <code>successors</code>, etc.) have branch (control flow)
significance.</p>
<h3 id="coveragespans"><a class="header" href="#coveragespans"><code>CoverageSpans</code></a></h3>
<p>The <code>struct</code> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/spans/struct.CoverageSpans.html"><code>CoverageSpans</code></a> builds and refines a final set of
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/spans/struct.CoverageSpan.html"><code>CoverageSpan</code></a>s, each representing the largest contiguous <code>Span</code>
of source within a single BCB. By definition--since each <code>Span</code> falls within a
BCB, the <code>Span</code> is also non-branching; so if any code in that <code>Span</code> has executed,
all code in the <code>Span</code> will have executed, the same number of times.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/spans/struct.CoverageSpans.html#method.generate_coverage_spans"><code>CoverageSpans::generate_coverage_spans()</code></a> constructs
an initial set of <code>CoverageSpan</code>s from the <code>Span</code>s associated with each MIR
<code>Statement</code> and <code>Terminator</code>.</p>
<p>The final stage of <code>generate_coverage_spans()</code> is handled by
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/spans/struct.CoverageSpans.html#method.to_refined_spans"><code>to_refined_spans()</code></a>, which iterates through the <code>CoverageSpan</code>s,
merges and de-duplicates them, and returns an optimal, minimal set of <code>CoverageSpan</code>s
that can be used to assign coverage <code>Counter</code>s or <code>Expression</code>s, one-for-one.</p>
<h3 id="make_bcb_counters"><a class="header" href="#make_bcb_counters"><code>make_bcb_counters()</code></a></h3>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/counters/struct.BcbCounters.html#method.make_bcb_counters"><code>make_bcb_counters()</code></a> traverses the <code>CoverageGraph</code> and adds a
<code>Counter</code> or <code>Expression</code> to every BCB. It uses <em>Control Flow Analysis</em>
to determine where an <code>Expression</code> can be used in place of a <code>Counter</code>.
<code>Expressions</code> have no runtime overhead, so if a viable expression (adding or
subtracting two other counters or expressions) can compute the same result as
an embedded counter, an <code>Expression</code> is preferred.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/coverage/graph/struct.TraverseCoverageGraphWithLoops.html"><code>TraverseCoverageGraphWithLoops</code></a>
provides a traversal order that ensures all <code>BasicCoverageBlock</code> nodes in a
loop are visited before visiting any node outside that loop. The traversal
state includes a <code>context_stack</code>, with the current loop's context information
(if in a loop), as well as context for nested loops.</p>
<p>Within loops, nodes with multiple outgoing edges (generally speaking, these
are BCBs terminated in a <code>SwitchInt</code>) can be optimized when at least one
branch exits the loop and at least one branch stays within the loop. (For an
<code>if</code> or <code>while</code>, there are only two branches, but a <code>match</code> may have more.)</p>
<p>A branch that does not exit the loop should be counted by <code>Expression</code>, if
possible. Note that some situations require assigning counters to BCBs before
they are visited by traversal, so the <code>counter_kind</code> (<code>CoverageKind</code> for
a <code>Counter</code> or <code>Expression</code>) may have already been assigned, in which case
one of the other branches should get the <code>Expression</code>.</p>
<p>For a node with more than two branches (such as for more than two
<code>match</code> patterns), only one branch can be optimized by <code>Expression</code>. All
others require a <code>Counter</code> (unless its BCB <code>counter_kind</code> was previously
assigned).</p>
<p>A branch expression is derived from the equation:</p>
<pre><code class="language-text">Counter(branching_node) = SUM(Counter(branches))
</code></pre>
<p>It's important to
be aware that the <code>branches</code> in this equation are the outgoing <em>edges</em>
from the <code>branching_node</code>, but a <code>branch</code>'s target node may have other
incoming edges. Given the following graph, for example, the count for
<code>B</code> is the sum of its two incoming edges:</p>
<p><img alt="Example graph with multiple incoming edges to a branch node"
 src="img/coverage-branch-counting-01.png" class="center" style="width: 25%">
<br/></p>
<p>In this situation, BCB node <code>B</code> may require an edge counter for its
&quot;edge from A&quot;, and that edge might be computed from an <code>Expression</code>,
<code>Counter(A) - Counter(C)</code>. But an expression for the BCB <em>node</em> <code>B</code>
would be the sum of all incoming edges:</p>
<pre><code class="language-text">Expression((Counter(A) - Counter(C)) + SUM(Counter(remaining_edges)))
</code></pre>
<p>Note that this is only one possible configuration. The actual choice
of <code>Counter</code> vs. <code>Expression</code> also depends on the order of counter
assignments, and whether a BCB or incoming edge counter already has
its <code>Counter</code> or <code>Expression</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="profile-guided-optimization.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="sanitizers.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="profile-guided-optimization.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="sanitizers.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="mermaid.min.js"></script>
        <script type="text/javascript" src="mermaid-init.js"></script>


    </body>
</html>
